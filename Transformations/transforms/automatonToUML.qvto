modeltype InteractionTable uses 'interactionTable';
modeltype BehaviourTable uses 'behaviourTable';
modeltype StateDiagram uses uml('http://www.eclipse.org/uml2/5.0.0/UML');
modeltype Automaton uses 'ioAutomaton';

transformation automatonToUML(in automaton : Automaton, out uml : StateDiagram);

main() {
	automaton.objectsOfKind(AutomatonPackage).map transformAutomatonPackage();

}


mapping AutomatonPackage::transformAutomatonPackage() : Set(StateMachine) {
	var diagrams := self.automatons.map transformAutomaton(); 
}


mapping IOAutomaton::transformAutomaton() : StateMachine {
	name := self.actor.name;
	
	var initialState := object Pseudostate {
		kind := PseudostateKind::initial;
		name := "init";
	};
	
	var initialTransition := object Transition {
		name := "initTrans";
		source := initialState;
		// TODO: this does not work this way, rewrite
		target := self.start.resolveone(StateDiagram::State);
	};
	
	
	var myRegion := object Region {
		name := "region of " + self.actor.name;
		subvertex += initialState;
		transition += initialTransition;
	};
	
	myRegion.subvertex += self.transitions.preState.map toStateSet(self, myRegion);
	
	
	region += myRegion;	
}

//transforms a State to a Set of a stable state and the corresponding activity states
//all states are properly linked with the right transitions
//respective the given automaton
mapping InteractionTable::State::toStateSet(in aut : IOAutomaton, inout region : Region) : Set(Vertex) {

	init {
		var stableState := object StateDiagram::State {
			name := self.name;
		};
		
		result += stableState;
		
		// we get all operations our object understands in the current state
		var ops := aut.getAllApplicableOps(self);
		
		log("");
		log("Object: " + aut.actor.name);
		log("State: " + self.name);
		
		
		//we get all corresponding behaviours we have to deal with
		while(not ops->isEmpty()) {
			var curOp := ops->any(true);
			var curBehs := aut.getAllBehaviours(self,curOp);
			
			if (curBehs->size() > 0) {
			

				var trans := object Transition {
					name := curOp;
					source := stableState;
					trigger += object Trigger {
						name := curOp;
					}
				};
				
				// make an activity state for the current set
				var activityState := object StateDiagram::State {
					name := curBehs->any(true).activation.name;
					submachine := curBehs->subStateMachine(trans);
				};
				
				trans.target := activityState;
				
				region.transition += trans;
				result += activityState;
				
				curBehs->collect(b | log(b.inMessage.name));
				
			};
			
			ops := ops->excluding(curOp);
		};
		
	}
			
}

helper Set(BehaviourTable::Behaviour)::subStateMachine(inout transition : Transition) : StateDiagram::StateMachine {
	return object StateMachine {
		name := "submachine for "+ self->any(true).activation.name;
		
		var myRegion := object Region {
			name := "region of " + self->any(true).activation.name;
		};
		
		var entryState := object Pseudostate {
			kind := PseudostateKind::entryPoint;
			name := "entryTo" + self->any(true).activation.name;
		};
		myRegion.subvertex += entryState;
		
		transition.target := entryState;
	
		var firstTrans = object Transition {
			name := "entryTransFrom" + self->any(true).activation.name;
			source := entryState;
		};
		myRegion.transition += firstTrans;
		
		
		myRegion.subvertex += self.activation->asSet()->toStateFragments(firstTrans,1, myRegion);

		region += myRegion;
		
	}
}

helper Set(BehaviourTable::Activation)::toStateFragments(inout transition : Transition, in offset : Integer, inout region : Region) : Set(Vertex) {
	
	// first of all find the longest common prefix
	var curOff := offset;
	var curOp := self->any(a | a.outMessages->size() > 0).outMessages->at(curOff);
	var commonPrefix : Sequence(BehaviourTable::OutMessage) = Sequence{};

	while(self->forAll(a | a.outMessages->at(curOff).operation.name = curOp.operation.name 
						and a.outMessages->at(curOff).returnType = curOp.returnType
						and a.outMessages->at(curOff).recvObject = curOp.recvObject)) {
						
		// common prefix found!
		commonPrefix += curOp;
		curOff := curOff+1;
		curOp := self->any(a | a.outMessages->size() > 0).outMessages->at(curOff);
		
	};
	
	var ret : Set(StateDiagram::Vertex) := Set{};
	var newTrans := transition;
	
	// Generate fragment with prefix
	if (commonPrefix->size() > 0) {
		var prefixState := object StateDiagram::State {
			name := "prefixState" + curOff.toString();
			doActivity := object StateDiagram::OpaqueBehavior {
				//TODO: receiver
				body += commonPrefix->collect(m | m.recvObject.name + "." + m.operation.name + ";\n");
			};
		};	
		transition.target := prefixState;
		newTrans := object Transition {
			name := "prefixOut" + curOff.toString();
			source := prefixState;
		};
		region.transition += newTrans;
		ret += prefixState;
	};
	
	// if after removing prefix something remains...
	if(curOff <= self->any(true).outMessages->size()) {
		
		// find out which branches we have to follow.
		// branches that start with the same prefix can stay together, so don't just split everything!
		var branches := self->collectNested(a | a->select(b | a.outMessages->at(curOff).operation.name = b.outMessages->at(curOff).operation.name));
		
		// build the state that is responsible for the case distinction
		var splitState := object StateDiagram::State {
			name := "splitState" + curOff.toString();
			doActivity := object StateDiagram::OpaqueBehavior {
				//TODO: receiver
				body += "check := " + self->any(true).outMessages->at(curOff).recvObject.name + "." + self->any(true).outMessages->at(curOff).operation.name;
			};
		};
		newTrans.target :=  splitState;	
		
		ret += splitState;
		
		// recursively call on all new distinct branches
		// TODO: define new transitions
		while(not branches->isEmpty()) {
			var coBranch := branches->any(true);
			var guardName := coBranch->asSequence()->at(curOff).outMessages->at(curOff).returnType;//self->any(b | b = coBranch).outMessages->at(curOff).returnType; //TODO falsch
			var branchTrans := object Transition {
				name := "splitTransition" + curOff.toString();
				source := splitState;
				guard := object Constraint {
					name := "[ check = " + guardName + "]";
				};
			};
			region.transition += branchTrans;
			ret += coBranch->toStateFragments(branchTrans,curOff+1,region);
			branches := branches->excluding(coBranch);
		};
		//ret += branches->collect(b | b->toStateFragments(transition,curOff+1,region));
		
	} else {
		var exitState := object Pseudostate {
			kind := PseudostateKind::exitPoint;
			name := "exit" + curOff.toString();// TODO name to find it again
		};
		newTrans.target := exitState;
		
		//self->any(true).postState.resolveone(Set(StateDiagram::State))->collect(n | log("s"+n.name));
		//self->any(true).outMessages->at(curOff).recvObject.resolveone(StateDiagram::State)->collect(n | log("t"+n.name));
		
		var exitTrans := object Transition {
			name := "prefixOut" + curOff.toString();
			source := exitState;
			//target :=  self->any(true).outMessages->at(curOff).recvObject.resolveone(Set(StateDiagram::State))->any(n | n.name = self->any(true).outMessages->at(curOff).recvObject.name);
		};
		
		
		ret += exitState;
	};
	
	return ret;
}

helper IOAutomaton::getAllBehaviours(in state : InteractionTable::State, in opName : String) : Set(BehaviourTable::Behaviour) {
	return self.transitions->select(b | b.preState = state and b.inMessage.name = opName);
}

helper IOAutomaton::getAllApplicableOps(in state : InteractionTable::State) : Set(String) {
	return self.transitions->collect(b | b.inMessage.name)->asSet();
}
