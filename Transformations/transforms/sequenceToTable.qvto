modeltype SequenceDiagram uses uml('http://www.eclipse.org/uml2/5.0.0/UML');
modeltype InteractionTable uses 'interactionTable';

transformation sequenceDiagramToTable(in seqDiagram : SequenceDiagram, out interactionTable : InteractionTable);

property knownStates : Set(InteractionTable::State);

main() {
	seqDiagram.objectsOfKind(Lifeline).map transformLifeline();
	seqDiagram.objectsOfKind(StateInvariant).map transformeStateInvariant();
	// don't transform the replies as they indicate the return type and no operation
	seqDiagram.objectsOfKind(Message)->select(m | m.messageSort != MessageSort::reply).map transformMessage();
	seqDiagram.objectsOfKind(Interaction).map transformInteraction();
}


mapping Interaction::transformInteraction() : Scenario {
	communications += seqDiagram.objectsOfKind(Lifeline)->coveredBy.map transformLifelineContents();
}

mapping StateInvariant::transformeStateInvariant() : InteractionTable::State 
	when {
		knownStates->select(s | s.name = self.name)->isEmpty();
	}{
	name := self.name;
	knownStates := knownStates->including(result);
} 

mapping Lifeline::transformLifeline() : CommObject {
	name := self.name;
}


mapping Message::transformMessage() : InteractionTable::Operation {
	name := self.name;
}


mapping Set(InteractionFragment)::transformLifelineContents(): Set(InteractionTable::Communication) {
	init {
		result := Set{};
		result += self[MessageOccurrenceSpecification]->select(o | self->includes(o.message.receiveEvent)).map transformMsgOcc();
	}

}

mapping OccurrenceSpecification::transformMsgOcc() : InteractionTable::Communication
	disjuncts
		MessageOccurrenceSpecification::transformMsgOccToSys,
		MessageOccurrenceSpecification::transformMsgOccToUser;	


mapping MessageOccurrenceSpecification::transformMsgOccToSys() : SystemCommunication
	when {
		self.message.messageSort = MessageSort::synchCall
	} {
	
	var recvOccSpecs := self.enclosingInteraction.fragment->select(f |  f.covered->includes(self.covered->any(true)));
	
	var myIdx := recvOccSpecs->indexOf(self); 
	
	returnType := recvOccSpecs->subOrderedSet(myIdx+1,recvOccSpecs->size())[MessageOccurrenceSpecification]->first().message.name;
		
		
	
	var statesBefore := recvOccSpecs->subOrderedSet(1,myIdx-1)[StateInvariant];
	var statesAfter := recvOccSpecs->subOrderedSet(myIdx+1,recvOccSpecs->size())[StateInvariant];
	
	log("");	
	log("operation: " + self.message.name);
	log("states: " + recvOccSpecs[StateInvariant]->size().toString());
	log("state before (" + statesBefore->size().toString() + "): " + statesBefore->last().name);
	log("state after (" + statesAfter->size().toString() + "): " + statesAfter->first().name);
	
	preState := statesBefore->last().resolveone(InteractionTable::State);
	postState := statesAfter->first().resolveone(InteractionTable::State);	

	message := self.transformToMessage();
}

mapping MessageOccurrenceSpecification::transformMsgOccToUser() : UserCommunication
	when {
		self.message.messageSort = MessageSort::asynchCall
	}{
	returnType := 'void';
	message := self.transformToMessage();
}


helper Message::getReceiver() : Lifeline {
	// we assume that the receive Event can only be a MessageOccurenceSpecification
	return self.receiveEvent[MessageOccurrenceSpecification].covered->any(true);
}

helper Message::getSender() : Lifeline {
	return self.sendEvent[MessageOccurrenceSpecification].covered->any(true);
	
}

helper MessageOccurrenceSpecification::transformToMessage() : CommMessage {
	var message := object CommMessage {
	
		sender := self.message.getSender().resolveone(CommObject);
		receiver := self.message.getReceiver().resolveone(CommObject);
		operation := self.message.resolveone(InteractionTable::Operation);

	};
	
	return message;
}