modeltype SequenceDiagram uses uml('http://www.eclipse.org/uml2/5.0.0/UML');
modeltype InteractionTable uses 'interactionTable';

transformation sequenceDiagramToTable(in seqDiagram : SequenceDiagram, out interactionTable : InteractionTable);

property knownStates : Set(InteractionTable::State);

main() {
	
	seqDiagram.objectsOfKind(StateInvariant).map transformeStateInvariant();
	seqDiagram.objectsOfKind(Lifeline).map transformLifeline();
	// don't transform the replies as they indicate the return type and no operation
	seqDiagram.objectsOfKind(Message)->select(m | m.messageSort != MessageSort::reply).map transformMessage();
	seqDiagram.objectsOfKind(Interaction).map transformInteraction();
}


mapping Interaction::transformInteraction() : Scenario {
	communications += seqDiagram.objectsOfKind(ExecutionSpecification).map transformExecSpec();
	communications += seqDiagram.objectsOfKind(MessageOccurrenceSpecification).map transformMsgOccToUser();
}

mapping StateInvariant::transformeStateInvariant() : InteractionTable::State 
	when {
		knownStates->select(s | s.name = self.name.substringAfter("_"))->isEmpty();
	}{
	name := self.name.substringAfter("_");
	knownStates := knownStates->including(result);
} 

helper StateInvariant::getState() : InteractionTable::State {
	return knownStates->select(s  | s.name = self.name.substringAfter("_"))->any(true);
}

mapping Lifeline::transformLifeline() : CommObject {
	name := self.name;
}


mapping Message::transformMessage() : InteractionTable::Operation {
	name := self.name;
}

mapping ExecutionSpecification::transformExecSpec() : InteractionTable::SystemCommunication 
	when {		
		self.start.oclIsKindOf(MessageOccurrenceSpecification);
		self.finish.oclIsKindOf(MessageOccurrenceSpecification);
	}{
	
	var invariantsOnLifeline := self.covered->any(true).coveredBy[StateInvariant];
	
	var returnType := "void";
	
	if (self.finish.oclAsType(MessageOccurrenceSpecification).message.messageSort = MessageSort::reply) {
		returnType := self.finish.oclAsType(MessageOccurrenceSpecification).message.name;
	};
	
	var myIdx := self.name.substringBefore("_").asInteger();
		
	var preState := invariantsOnLifeline->select(i | i.name.substringBefore("_").asInteger() < myIdx)->sortedBy(i | i.name.substringBefore("_").asInteger())->last();
	var postState := invariantsOnLifeline->select(i | i.name.substringBefore("_").asInteger() > myIdx)->sortedBy(i | i.name.substringBefore("_").asInteger())->first();
	
	
	result.preState := preState.getState();
	result.postState := postState.getState();
	result.returnType := returnType;
	result.message := self.start.oclAsType(MessageOccurrenceSpecification).transformToMessage();
	
	log("----SYSTEM COMMUNICATION----");
	log(result.message.sender.name + " -> " + result.message.receiver.name);	
	log("operation: " + result.message.operation.name);
	log("result: " + returnType);
	log("state before: " + result.preState.name);
	log("state after: " + result.postState.name);
	log("");
}


mapping MessageOccurrenceSpecification::transformMsgOccToUser() : UserCommunication
	when {
		self.message.messageSort = MessageSort::asynchCall;
		self.message.receiveEvent = self;
	}{
	
	returnType := 'void';
	message := self.transformToMessage();
	
	log("----USER COMMUNICATION----");	
	log(result.message.sender.name + " -> " + result.message.receiver.name);
	log("operation: " + result.message.operation.name);
	log(self.message.name);
	log("result: " + returnType);
	log("");
	
}


helper Message::getReceiver() : Lifeline {
	// we assume that the receive Event can only be a MessageOccurenceSpecification
	return self.receiveEvent[MessageOccurrenceSpecification].covered->any(true);
}

helper Message::getSender() : Lifeline {
	return self.sendEvent[MessageOccurrenceSpecification].covered->any(true);
	
}

helper MessageOccurrenceSpecification::transformToMessage() : CommMessage {
	var message := object CommMessage {
		sender := self.message.getSender().resolveone(CommObject);
		receiver := self.message.getReceiver().resolveone(CommObject);
		operation := self.message.resolveone(InteractionTable::Operation);
	};
	return message;
}